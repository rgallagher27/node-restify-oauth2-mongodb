{
  "name": "restify-oauth2",
  "description": "A simple OAuth 2 endpoint for Restify",
  "keywords": [
    "restify",
    "oauth",
    "oauth2",
    "rest",
    "authorization",
    "authentication",
    "api"
  ],
  "version": "4.0.0",
  "author": {
    "name": "Domenic Denicola",
    "email": "domenic@domenicdenicola.com",
    "url": "http://domenic.me/"
  },
  "license": "WTFPL",
  "repository": {
    "type": "git",
    "url": "git://github.com/domenic/restify-oauth2.git"
  },
  "bugs": {
    "url": "http://github.com/domenic/restify-oauth2/issues"
  },
  "main": "lib/index.js",
  "scripts": {
    "test": "npm run test-ropc-unit && npm run test-cc-unit && npm run test-ropc-integration && npm run test-cc-integration && npm run test-cc-with-scopes-integration",
    "test-ropc-unit": "mocha test/ropc-unit.coffee --reporter spec --compilers coffee:coffee-script",
    "test-cc-unit": "mocha test/cc-unit.coffee --reporter spec --compilers coffee:coffee-script",
    "test-ropc-integration": "vows test/ropc-integration.coffee --spec",
    "test-cc-integration": "vows test/cc-integration.coffee --spec",
    "test-cc-with-scopes-integration": "vows test/cc-with-scopes-integration.coffee --spec",
    "lint": "jshint lib && jshint examples"
  },
  "dependencies": {
    "underscore": "1.x"
  },
  "peerDependencies": {
    "restify": "2.x"
  },
  "devDependencies": {
    "api-easy": "~0.3.8",
    "coffee-script": "1.6.3",
    "chai": "^1.9.0",
    "jshint": "^2.4.4",
    "mocha": "~1.17.1",
    "restify": "^2.6.3",
    "sinon": "^1.9.0",
    "sinon-chai": "^2.5.0",
    "vows": "~0.7.0"
  },
  "readme": "# OAuth 2 Endpoints for Restify\n\nThis package provides a *very simple* OAuth 2.0 endpoint for the [Restify][] framework. In particular, it implements\nthe [Client Credentials][cc] and [Resource Owner Password Credentials][ropc] flows only.\n\n## What You Get\n\nIf you provide Restify–OAuth2 with the appropriate hooks, it will:\n\n* Set up a [token endpoint][], which returns [access token responses][token-endpoint-success] or\n  [correctly-formatted error responses][token-endpoint-error].\n* For all other resources, when an access token is [sent via the `Authorization` header][send-token], it will validate\n  it:\n  * If the token fails validation, it will send [an appropriate 400 or 401 error response][token-usage-error], with a\n    [`WWW-Authenticate`][www-authenticate] header and a [`Link`][web-linking] [`rel=\"oauth2-token\"`][oauth2-token-rel]\n    header pointing to the token endpoint.\n  * Otherwise, you can use your `authenticateToken` and `grantScopes` hooks to set properties on the request object for\n    your routes to check later.\n* If no access token is sent, it ensures that `req.username` is set to `null`; furthermore, none of your hooks are\n  called, so you can be sure that no properties that they set are present.\n  * You can then check for these conditions whenever there is a resource you want to protect.\n  * If the user tries to access a protected resource, you can use Restify–OAuth2's `res.sendUnauthenticated()` to send\n    appropriate 401 errors with helpful `WWW-Authenticate` and `Link` headers, or its `res.sendUnauthorized()` to send\n    appropriate 403 errors with similar headers.\n\n## Use and Configuration\n\nTo use Restify–OAuth2, you'll need to pass it your server plus some options, including the hooks discussed below.\nRestify–OAuth2 also depends on the built-in `authorizationParser` and `bodyParser` plugins, the latter with `mapParams`\nset to `false`. So in short, it looks like this:\n\n```js\nvar restify = require(\"restify\");\nvar restifyOAuth2 = require(\"restify-oauth2\");\n\nvar server = restify.createServer({ name: \"My cool server\", version: \"1.0.0\" });\nserver.use(restify.authorizationParser());\nserver.use(restify.bodyParser({ mapParams: false }));\n\nrestifyOAuth2.cc(server, options);\n// or\nrestifyOAuth2.ropc(server, options);\n```\n\nUnfortunately, Restify–OAuth2 can't be a simple Restify plugin. It needs to install a route for the token\nendpoint, whereas plugins simply run on every request and don't modify the server's routing table.\n\n## Options\n\nThe options you pass to Restify–OAuth2 depend heavily on which of the two flows you are choosing. There are some\noptions common to both flows, but the `options.hooks` hash will vary depending on the flow. Once you provide the\nappropriate hooks, you get an OAuth 2 implementation for free.\n\n### Client Credentials Hooks\n\nThe idea behind this very simple OAuth 2 flow is that your API clients identify themselves with client IDs and secrets,\nand if those values authenticate, you grant them an access token they can use for further requests. The advantage of\nthis over simply requiring basic access authentication headers on every request is that now you can set those tokens to\nexpire, or revoke them if they fall in to the wrong hands.\n\nTo install Restify–OAuth2's client credentials flow into your infrastructure, you will need to provide it with the\nfollowing hooks in the `options.hooks` hash. You can see some [example CC hooks][] in the demo application.\n\n#### `grantClientToken({ clientId, clientSecret }, req, cb)`\n\nChecks that the API client is authorized to use your API, and has the correct secret. It should call back with a new\ntoken for that client if so, or `false` if the credentials are incorrect. It can also call back with an error if there\nwas some internal server error while validating the credentials.\n\n#### `authenticateToken(token, req, cb)`\n\nChecks that a token is valid, i.e. that it was granted in the past by `grantClientToken`. It should call back with\n`true` if so, or `false` if the token is invalid. It can also call back with an error if there was some internal\nserver error while looking up the token. If the token is valid, it is likely useful to set a property on the request\nobject indicating that so that your routes can check it later, e.g. `req.authenticated = true` or\n`req.clientId = lookupClientIdFrom(token)`.\n\n### Resource Owner Password Credentials Hooks\n\nThe idea behind this OAuth 2 flow is that your API clients will prompt the user for their username and password, and\nsend those to your API in exchange for an access token. This has some advantages over simply sending the user's\ncredentials to the server directly. For example, it obviates the need for the client to store the credentials, and\nallows expiration and revocation of tokens. However, it does imply that you trust your API clients, since they will\nhave at least one-time access to the user's credentials.\n\nTo install Restify–OAuth2's resource owner password credentials flow into your infrastructure, you will need to\nprovide it with the following hooks in the `options.hooks` hash. You can see some [example ROPC hooks][] in the demo\napplication.\n\n#### `validateClient({ clientId, clientSecret }, req, cb)`\n\nChecks that the API client is authorized to use your API, and has the correct secret. It should call back with `true`\nor `false` depending on the result of the check. It can also call back with an error if there was some internal server\nerror while doing the check.\n\n#### `grantUserToken({ clientId, clientSecret, username, password }, req, cb)`\n\nChecks that the API client is authenticating on behalf of a real user with correct credentials. It should call back\nwith a new token for that user if so, or `false` if the credentials are incorrect. It can also call back with an error\nif there was some internal server error while validating the credentials.\n\n#### `authenticateToken(token, req, cb)`\n\nChecks that a token is valid, i.e. that it was granted in the past by `grantUserToken`. It should call back with\n`true` if so, or `false` if the token is invalid. It can also call back with an error if there was some internal\nserver error while looking up the token. If the token is valid, it is likely useful to set a property on the request\nobject indicating that so that your routes can check it later, e.g. `req.authenticated = true` or\n`req.username = lookupUsernameFrom(token)`.\n\n### Scope-Granting Hook\n\nOptionally, it is possible to limit the [scope][] of the issued tokens, so that you can implement an authorization\nsystem in your application in addition to simple authentication.\n\n#### `grantScopes(credentials, scopesRequested, req, cb)`\n\nThis hook is called after the token has been granted by `authenticateToken`. In the client credentials flow,\n`credentials` will be `{ clientId, clientSecret, token }`; in the resource owner password credentials flow, it will be\n`{ clientId, clientSecret, username, password, token }`. In both cases, `scopesRequested` will be an array of the\nrequested scopes.\n\nThis hook can respond in several ways:\n\n* It can call back with `true` to grant all of the requested scopes.\n* It can call back with `false` to indicate that the requested scopes are invalid, unknown, or exceed the set of scopes\n  that should be granted to the given credentials.\n* It can call back with an array to grant a different set of scopes.\n* It can call back with an error if there was some internal server error while granting scopes.\n\nIn the cases of `false` or an internal server error, you should probably revoke the token before calling back, as the\nserver will send the user an error response, instead of a successful token grant.\n\n### Other Options\n\nThe `hooks` hash is the only required option, but the following are also available for tweaking:\n\n* `tokenEndpoint`: the location at which the token endpoint should be created. Defaults to `\"/token\"`.\n* `wwwAuthenticateRealm`: the value of the \"Realm\" challenge in the `WWW-Authenticate` header. Defaults to\n  `\"Who goes there?\"`.\n* `tokenExpirationTime`: the value returned for the `expires_in` component of the response from the token endpoint.\n  Note that this is *only* the value reported; you are responsible for keeping track of token expiration yourself and\n  calling back with `false` from `authenticateToken` when the token expires. Defaults to `Infinity`.\n\n## What Does That Look Like?\n\nOK, let's try something a bit more concrete. If you check out the [example servers][] used in the integration tests,\nyou'll see our setup. Here we'll walk you through the more complicated resource owner password credentials example,\nbut the idea for the client credentials example is very similar.\n\n## /\n\nThe initial resource, at which people enter the server.\n\n* If a valid token is supplied in the `Authorization` header, `req.username` is truthy, and the app responds with\n  links to `/public` and `/secret`.\n* If no token is supplied, the app responds with links to `/token` and `/public`.\n* If an invalid token is supplied, Restify–OAuth2 intercepts the request before it gets to the application, and sends\n  an appropriate 400 or 401 error.\n\n## /token\n\nThe token endpoint, managed entirely by Restify–OAuth2. It generates tokens for a given client ID/client\nsecret/username/password combination.\n\nThe client validation and token-generation logic is provided by the application, but none of the ceremony necessary for\nOAuth 2 conformance, error handling, etc. is present in the application code: Restify–OAuth2 takes care of all of that.\n\n## /public\n\nA public resource anyone can access.\n\n* If a valid token is supplied in the Authorization header, `req.username` contains the username, and the app uses\n  that to send a personalized response.\n* If no token is supplied, `req.username` is `null`. The app still sends a response, just without personalizing.\n* If an invalid token is supplied, Restify–OAuth2 intercepts the request before it gets to the application, and sends\n  an appropriate 400 or 401 error.\n\n## /secret\n\nA secret resource that only authenticated users can access.\n\n* If a valid token is supplied in the Authorization header, `req.username` is truthy, and the app sends the secret\n  data.\n* If no token is supplied, `req.username` is `null`, so the application uses `res.sendUnauthenticated()` to send a nice\n  401 error with `WWW-Authenticate` and `Link` headers.\n* If an invalid token is supplied, Restify–OAuth2 intercepts the request before it gets to the application, and sends\n  an appropriate 400 or 401 error.\n\n[Restify]: http://mcavage.github.com/node-restify/\n[cc]: http://tools.ietf.org/html/rfc6749#section-1.3.4\n[ropc]: http://tools.ietf.org/html/rfc6749#section-1.3.3\n[token endpoint]: http://tools.ietf.org/html/rfc6749#section-3.2\n[token-endpoint-success]: http://tools.ietf.org/html/rfc6749#section-5.1\n[token-endpoint-error]: http://tools.ietf.org/html/rfc6749#section-5.2\n[send-token]: http://tools.ietf.org/html/rfc6750#section-2.1\n[token-usage-error]: http://tools.ietf.org/html/rfc6750#section-3.1\n[oauth2-token-rel]: http://tools.ietf.org/html/draft-wmills-oauth-lrdd-07#section-3.2\n[web-linking]: http://tools.ietf.org/html/rfc5988\n[www-authenticate]: http://tools.ietf.org/html/rfc2617#section-3.2.1\n[scope]: http://tools.ietf.org/html/rfc6749#section-3.3\n[example ROPC hooks]: https://github.com/domenic/restify-oauth2/blob/master/examples/ropc/hooks.js\n[example CC hooks]: https://github.com/domenic/restify-oauth2/blob/master/examples/cc/hooks.js\n[example servers]: https://github.com/domenic/restify-oauth2/tree/master/examples\n",
  "readmeFilename": "README.md",
  "_id": "restify-oauth2@4.0.0",
  "_from": "restify-oauth2@4.0.0",
  "dist": {
    "shasum": "0548457a6a2efce9c055f763d80e1b5a61ffad13"
  },
  "_resolved": "https://registry.npmjs.org/restify-oauth2/-/restify-oauth2-4.0.0.tgz"
}
